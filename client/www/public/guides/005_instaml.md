# InstaML: InstantDB Transaction API Guide

InstaML is InstantDB's mutation language for creating, updating, and deleting data.

## Core Concepts

- **Transactions**: Groups of operations that execute atomically
- **Transaction Chunks**: Individual operations within a transaction
- **Proxy Syntax**: The `db.tx` object that creates transaction chunks

## Basic Structure

Every transaction follows this pattern:
```typescript
db.transact(db.tx.NAMESPACE[ENTITY_ID].ACTION(DATA));
```

Where:
- `NAMESPACE` is your collection (like "todos" or "users")
- `ENTITY_ID` is the unique ID of an entity. It **MUST** be a valid UUID which can be generated by `id()` or found using `lookup()`.
  `lookup()` to find an existing one.
- `ACTION` is the operation (update, merge, delete, link, unlink)
- `DATA` is the information needed for the action

## Generating valid Entity IDs

Entity IDs must be valid UUIDs. You can generate valid entity IDs using the `id()` or `lookup()` function.

### Generating IDs with `id()`

Use `id()` to generate a new unique ID for an entity:

```typescript
import { id } from '@instantdb/react';

// ✅ Good: Use `id()` to generate a new unique ID
const newTodoId = id();
db.transact(db.tx.todos[newTodoId].update({ text: "New todo" }));

// ✅ Good: You can also inline `id()` directly
db.transact(db.tx.todos[id()].update({ text: "Another todo" }));
```

❌ **Common mistake**: Manually creating non-UUID IDs
```typescript
// ❌ Bad: ids must be valid UUIDs
db.transact(db.tx.todos["todo-" + Math.random().toString(36).substring(2)].update({
  text: "Custom ID todo"
}));
```

### Looking Up by Unique Attributes

Use `lookup` on unique attributes to get or create entity ids. Unique attributes
must be defined in your schema.

```typescript
// instant.schema.ts
import { i } from '@instantdb/react';

const _schema = i.schema({
  entities: {
    $users: i.entity({
      email: i.string().unique().indexed(),
    }),
    profiles: i.entity({
      handle: i.string().unique(),
      role: i.string(),
      bio: i.string(),
    }),
  },
  links: {
    profileUser: {
      forward: { on: 'profiles', has: 'one', label: '$user' },
      reverse: { on: '$users', has: 'one', label: 'profile' },
    },
  },
});

type _AppSchema = typeof _schema;
interface AppSchema extends _AppSchema {}
const schema: AppSchema = _schema;

export type { AppSchema };
export default schema;

// lib/db.ts
import { init } from '@instantdb/react';
import schema from './instant.schema';

export const db = init({
  appId: process.env.INSTANT_APP_ID,
  schema
});

// app/page.tsx
import { lookup } from '@instantdb/react';
import { db } from '../lib/db';

// ✅ Good: Update a profile by looking up a unique attribute
// This will create a new profile if it doesn't exist
// or update the existing one
db.transact(
  db.tx.profiles[lookup('handle', 'nezaj')].update({
    bio: 'I like turtles'
  })
);

```
❌ **Common mistake**: Using lookup on non-unique fields
```typescript
// ... Using same schema as above
// ❌ Bad: Using lookup on a non-unique field will throw an error
db.transact(
  // 'role' is not marked as unique in the schema!
  db.tx.profiles[lookup('role', 'admin')].update({
    bio: 'I like turtles'
  })
);
```

## Creating Entities

### Creating New Entities

Always use `update` method to create new entities:

```typescript
// ✅ Good: Always use `update` to create new entities
db.transact(db.tx.todos[id()].update({
  text: "Properly generated ID todo"
}));
```

❌ **Common mistake**: Using a non-existent `create` method
```typescript
// ❌ Bad: `create` does not exist, use `update` instead!
db.transact(db.tx.todos[id()].create({ text: "Buy groceries" }));
```

❌ **Common mistake**: Calling `update` on `$users` namespace
```typescript
// ❌ Bad: `$users` is a special system table, don't update it directly. You can only link or unlink to it.
db.transact(db.tx.$users[id()].update({
  email: "new-user@instantdb.com"
}));
```

### Storing Different Data Types

You can store various data types in your entities:

```typescript
// ✅ Good: Store different types of data
db.transact(db.tx.todos[id()].update({
  text: "Complex todo",          // String
  priority: 1,                   // Number
  completed: false,              // Boolean
  tags: ["work", "important"],   // Array
  metadata: {                    // Object
    assignee: "user-123",
    dueDate: "2025-01-15"
  }
}));
```

## Updating Entities

### Basic Updates

Update existing entities with new values:

```typescript
// ✅ Good: Update a specific field
// ... Assume todoId is a valid ID of an existing todo
db.transact(db.tx.todos[todoId].update({ done: true }));

// ✅ Good: When linking to $users, use the special $users namespace
// This is an example of how to connect a todo to the current authenticated user
db.transact(db.tx.todos[todoId].link({ $users: auth.userId }));
```

This will only change the specified field(s), leaving other fields untouched.

### Deep Merging Objects

Use `merge` for updating nested objects without overwriting unspecified fields:

```typescript
// ✅ Good: Update nested values without losing other data
db.transact(db.tx.profiles[userId].merge({
  preferences: {
    theme: "dark"
  }
}));
```

❌ **Common mistake**: Using `update` for nested objects
```typescript
// ❌ Bad: This will overwrite the entire preferences object
db.transact(db.tx.profiles[userId].update({
  preferences: { theme: "dark" }  // Any other preferences will be lost
}));
```

### Removing Object Keys

Remove keys from nested objects by setting them to `null`:

```typescript
// ✅ Good: Remove a nested key
db.transact(db.tx.profiles[userId].merge({
  preferences: {
    notifications: null  // This will remove the notifications key
  }
}));
```

❌ **Common mistake**: Calling `update` instead of `merge` for removing keys
```typescript
// ❌ Bad: Calling `update` will overwrite the entire preferences object
db.transact(db.tx.profiles[userId].update({
  preferences: {
    notifications: null
  }
}));
```

## Deleting Entities

Delete entities completely:

```typescript
// ✅ Good: Delete a specific entity
db.transact(db.tx.todos[todoId].delete());
```

Delete multiple entities:

```typescript
// ✅ Good: Delete multiple entities
db.transact([
  db.tx.todos[todoId1].delete(),
  db.tx.todos[todoId2].delete(),
  db.tx.todos[todoId3].delete()
]);
```

Delete all entities that match a condition:

```typescript
// ✅ Good: Delete all completed todos
const { data } = db.useQuery({ todos: {} });
const completedTodos = data.todos.filter(todo => todo.done);

db.transact(
  completedTodos.map(todo => db.tx.todos[todo.id].delete())
);
```

## Creating Relationships

### Linking Entities

Create relationships between entities:

```typescript
// ✅ Good: Create a new project and todo and link them
import { id } from '@instantdb/react';

const todoId = id();
const projectId = id();
db.transact([
  db.tx.todos[todoId].update({ text: "New todo", done: false }),
  db.tx.projects[projectId].update({ name: "New project" }).link({ todos: todoId
  })
]);
```

Link multiple entities at once:

```typescript
// ✅ Good: Link multiple todos to a project
//... Assume projectId, todoId1, todoId2, todoId3 are already created
db.transact(db.tx.projects[projectId].link({
  todos: [todoId1, todoId2, todoId3]
}));
```

### Linking in Both Directions

Links are bidirectional - you can query from either side:

```typescript
// These do the same thing:
db.transact(db.tx.projects[projectId].link({ todos: todoId }));
db.transact(db.tx.todos[todoId].link({ projects: projectId }));
```

### Removing Links

Remove relationships with `unlink`:

```typescript
// ✅ Good: Unlink a todo from a project
db.transact(db.tx.projects[projectId].unlink({ todos: todoId }));

// Unlink multiple todos at once
db.transact(db.tx.projects[projectId].unlink({
  todos: [todoId1, todoId2, todoId3]
}));
```

## Advanced Features

### Lookups in Relationships

You can use `lookup` to link entities by unique attributes:

```typescript
// ✅ Good: Link entities using lookups
db.transact(
  db.tx.profiles[lookup('email', 'user@example.com')].link({
    projects: lookup('name', 'Project Alpha')
  })
);
```

### Combining Multiple Operations

You can combine multiple operations in a single transaction. This is useful for
creating, updating, and linking entities in one atomic operation:

```typescript
// ✅ Good: Update and link in one transaction
db.transact(
  db.tx.todos[id()]
    .update({ text: "New todo", done: false })
    .link({ projects: projectId })
);
```

```typescript
// ✅ Good: Multiple operations in one atomic transaction
db.transact([
  db.tx.todos[todoId].update({ done: true }),
  db.tx.projects[projectId].update({ completedCount: 10 }),
  db.tx.stats[statsId].merge({ lastCompletedTodo: todoId })
]);
```

## Performance Optimization

### Batching Large Transactions

Large transactions can lead to timeouts. To avoid this, break them into smaller batches:

```typescript
// ✅ Good: Batch large operations
import { id } from '@instantdb/react';

const batchSize = 100;
const createManyTodos = async (count) => {
  for (let i = 0; i < count; i += batchSize) {
    const batch = [];
    
    // Create up to batchSize transactions
    for (let j = 0; j < batchSize && i + j < count; j++) {
      batch.push(
        db.tx.todos[id()].update({
          text: `Todo ${i + j}`,
          done: false
        })
      );
    }
    
    // Execute this batch
    await db.transact(batch);
  }
};

// Create 1000 todos in batches
createManyTodos(1000);
```

❌ **Common mistake**: Not batching large transactions leads to timeouts
```typescript
import { id } from '@instantdb/react';

const txs = [];
for (let i = 0; i < 1000; i++) {
  txs.push(
    db.tx.todos[id()].update({
      text: `Todo ${i}`,
      done: false
    })
  );
}

// ❌ Bad: This will likely lead to a timeout!
await db.transact(txs);
```

❌ **Common mistake**: Creating too many transactions will also lead to timeouts
```typescript
import { id } from '@instantdb/react';

// ❌ Bad: This fire 1000 transactions at once and will lead to multiple
timeouts!
for (let i = 0; i < 1000; i++) {
  db.transact(
    db.tx.todos[id()].update({
      text: `Todo ${i}`,
      done: false
    })
  );
}

await db.transact(txs);
```

## Common Patterns

### Create-or-Update Pattern

Use `lookup` to create or update an entity based on its unique attribute:

```typescript
// ✅ Good: Create if doesn't exist, update if it does
db.transact(
  db.tx.profiles[lookup('email', 'user@example.com')].update({
    lastLoginAt: Date.now()
  })
);
```

### Toggle Boolean Flag

Efficiently toggle boolean values:

```typescript
// ✅ Good: Toggle a todo's completion status
const toggleTodo = (todo) => {
  db.transact(
    db.tx.todos[todo.id].update({ done: !todo.done })
  );
};
```

### Dependent Transactions

Wait for one transaction to complete before starting another:

```typescript
// ✅ Good: Sequential dependent transactions
const createProjectAndTasks = async (projectData) => {
  // First create the project
  const result = await db.transact(
    db.tx.projects[id()].update(projectData)
  );
  
  // Then create tasks linked to the project
  const projectId = result.ids.projects[0]; // Get ID from the result
  await db.transact(
    db.tx.tasks[id()].update({
      title: "Initial planning",
      createdAt: Date.now()
    }).link({ project: projectId })
  );
};
```

## Error Handling

You can handle transaction errors by wrapping transactions in a try/catch block

```typescript
try {
  await db.transact(/* ... */);
} catch (error) {
  console.error("Transaction failed:", error);
  // Handle the error appropriately
}
```

